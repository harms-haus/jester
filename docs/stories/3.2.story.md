# Story 3.2: LightRAG Query Integration

## Story Information
- **Epic**: 3 - LightRAG Integration
- **Story Number**: 3.2
- **Status**: Draft
- **Created**: 2025-01-27
- **Last Modified**: 2025-01-27

## Story Statement

As a **parent creating bedtime stories**,
I want **the system to query LightRAG for relevant entities**,
so that **my stories can include discovered characters, locations, and items**.

## Acceptance Criteria

1. **Context generation** queries LightRAG for relevant entities during `/muse` command
2. **Entity suggestions** are provided based on story context and requirements
3. **Entity filtering** allows selection of relevant entities from LightRAG results
4. **Entity integration** incorporates selected entities into local story context
5. **Entity validation** ensures suggested entities fit the story requirements
6. **Entity export** saves selected entities to local entity files
7. **Query optimization** minimizes LightRAG queries while maximizing relevance

## Tasks / Subtasks

- [ ] Task 1: Implement LightRAG Context Generation (AC: 1)
  - [ ] 1.1. Integrate LightRAG queries into `/muse` command workflow
  - [ ] 1.2. Create context-aware query generation based on story requirements
  - [ ] 1.3. Implement query result processing and entity extraction
  - [ ] 1.4. Add query result caching to minimize API calls
  - [ ] 1.5. Create error handling for LightRAG service unavailability

- [ ] Task 2: Implement Entity Suggestion System (AC: 2)
  - [ ] 2.1. Create entity suggestion algorithm using LightRAG query results
  - [ ] 2.2. Implement suggestion ranking based on relevance scores
  - [ ] 2.3. Add suggestion reasoning and explanation generation
  - [ ] 2.4. Create suggestion presentation and formatting
  - [ ] 2.5. Implement suggestion validation against story context

- [ ] Task 3: Implement Entity Filtering System (AC: 3)
  - [ ] 3.1. Create entity type filtering (character, location, item)
  - [ ] 3.2. Implement relevance score filtering
  - [ ] 3.3. Add keyword-based entity filtering
  - [ ] 3.4. Create combined filter logic for multiple criteria
  - [ ] 3.5. Implement filter persistence and user preferences

- [ ] Task 4: Implement Entity Integration (AC: 4)
  - [ ] 4.1. Create entity integration into story context files
  - [ ] 4.2. Implement entity reference management in context
  - [ ] 4.3. Add entity metadata tracking and usage counting
  - [ ] 4.4. Create entity relationship mapping in context
  - [ ] 4.5. Implement integration validation and error handling

- [ ] Task 5: Implement Entity Validation System (AC: 5)
  - [ ] 5.1. Create entity validation against story requirements
  - [ ] 5.2. Implement entity type and property validation
  - [ ] 5.3. Add entity consistency checking with existing context
  - [ ] 5.4. Create validation error reporting and suggestions
  - [ ] 5.5. Implement validation bypass for user override

- [ ] Task 6: Implement Entity Export Functionality (AC: 6)
  - [ ] 6.1. Create entity export to local entity files (characters/, locations/, items/)
  - [ ] 6.2. Implement entity file creation with proper formatting
  - [ ] 6.3. Add entity metadata and relationship preservation
  - [ ] 6.4. Create export validation and conflict resolution
  - [ ] 6.5. Implement export rollback and error recovery

- [ ] Task 7: Implement Query Optimization (AC: 7)
  - [ ] 7.1. Create query batching to reduce LightRAG API calls
  - [ ] 7.2. Implement query result caching with TTL
  - [ ] 7.3. Add query deduplication and result reuse
  - [ ] 7.4. Create query performance monitoring and metrics
  - [ ] 7.5. Implement offline mode with cached data fallback

## Dev Notes

### Previous Story Insights
From Story 3.1 (Entity Relationship Discovery), the system has established LightRAG integration capabilities for relationship discovery. This story builds upon that foundation by integrating LightRAG queries directly into the `/muse` command workflow for entity discovery during story creation.

### Data Models
[Source: architecture/data-models.md#Core Data Structures]

**Key Data Structures:**
- `StoryContext` with entities containing EntityReference arrays for characters, locations, and items
- `Entity` interface with id, name, type, description, properties, relationships, last_used, usage_count
- Entity types: 'character' | 'location' | 'item'

**Context File Structure:**
- YAML format for context files in `contexts/` directory
- Entity references with metadata and usage tracking
- Story requirements and target audience information

### API Specifications
[Source: architecture/api-specification.md#LightRAG OpenAPI Integration]

**Key LightRAG Endpoints:**
- `POST /query` - Natural language queries with reranking support
- `POST /query/data` - Structured data queries for knowledge graph entities and relationships
- `GET /graph/label/list` - Retrieve all node labels (IDs) in the datastore
- `GET /graphs` - Get graph node data

**Request/Response Format:**
- QueryRequest: { query: string, documents?: Array<{content: string, id: string}>, enable_rerank?: boolean }
- QueryResponse: { reranked_documents: Array<{content: string, id: string, score: number}> }
- DataQueryResponse: Contains entities, relationships, and chunks arrays with detailed metadata

**LightRAGClient Interface:**
- query(query: string, enableRerank?: boolean): Promise<QueryResponse>
- queryData(query: string, format?: string, includeVectors?: boolean): Promise<DataQueryResponse>
- getGraphLabels(): Promise<GraphLabelListResponse>
- getGraphNodes(): Promise<GraphNodeDataResponse>

### Component Specifications
[Source: architecture/components.md#Core Components]

**Agent System Integration:**
- `/muse` (Story Context Agent): Prompt rules for context gathering and entity discovery (Analyst role)
- External LLM follows Muse prompt rules to query LightRAG for entities
- LLM generates context file and saves to `contexts/` per prompt instructions

**File System Operations:**
- Entity file management (characters/, locations/, items/) via LLM operations
- Story file management (stories/, outlines/, contexts/) via LLM operations
- Wiki-style link parsing and validation via LLM operations

**Data Flow:**
1. User initiates `/muse` command
2. External LLM follows Muse prompt rules to query LightRAG for entities
3. LLM generates context file and saves to `contexts/` per prompt instructions
4. User edits context file
5. User runs `/write outline` and `/write story` commands

### File Locations
[Source: architecture/data-models.md#File System Structure]

**Project Structure:**
- Context files: `contexts/` directory
- Entity files: `entities/characters/`, `entities/locations/`, `entities/items/`
- LightRAG client: `src/clients/lightragClient.ts`
- Services: `src/services/lightragService.ts`
- Agent prompt rules: `.jester/agents/` (Muse agent)

### Technical Constraints
[Source: architecture/tech-stack.md#External Services]

**Dependencies:**
- LightRAG: Knowledge graph service for entity relationships
- MCP Client: Python client for LightRAG OpenAPI integration
- External LLM: Any LLM service capable of following prompt rules and performing file operations

**Performance Considerations:**
- Query caching to minimize LightRAG API calls
- Offline mode when LightRAG service unavailable
- Reranking enabled by default for better relevance
- Streaming support for real-time query results

**Architectural Patterns:**
- Agent-Based Architecture: Specialized agents with specific responsibilities
- File-Based Pipeline: Agents communicate through structured files
- Local-First Storage: All user data stored locally with optional cloud sync
- Knowledge Graph Integration: External knowledge graph for entity relationships

### Testing Requirements
No specific testing strategy found in architecture docs. Following general coding standards:
- Use try-catch blocks for async operations
- Provide meaningful error messages
- Log errors with context information
- Graceful degradation for non-critical failures

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-27 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be populated here*

